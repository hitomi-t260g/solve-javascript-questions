// 何が出力されるでしょうか？

for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

// A: 0 1 2 と 0 1 2
// B: 0 1 2 と 3 3 3
// C: 3 3 3 と 0 1 2

//varがグローバル変数であり、letとconstがブロックスコープ変数であることを利用した問題

//ループの仕組みとして、setTimeOutは非同期APIに値する。よってfor内の setTimeout は、forループを抜けたあとで実行される。
//イベントループは、「現在実行中のタスクがないこと」と「タスクキューにタスクがあるか」を繰り返し確認します。簡単にまとめると次のようになります。
// 1. すべての非同期APIは作業完了後、コールバック関数をタスクキューに追加する。
// 2. イベントループは、現在実行中のタスクがない（コールスタックが空になった）場合、FIFO(First in first out, 先着順)でタスクキューから取り出して実行する。
// 3. 現在実行中のコールタスクがある(コールスタックに関数がある)場合、LIFO(Last in first out, 座布団とかバスの出入り口式)でコールスタックから取り出して実行する。

// 処理の流れ
// 1. setTimeOutのコールバック関数の() => console.log(i)がWeb APIに追加され、1ms待機します。
// 2. その瞬間setTimeoutはコールスタックからポップされ、値を返します（「CBが1ms待ちです」）。
// 3. 1ms後、() => console.log(i)は直ぐにコールスタックに追加されるのではなく、タスクキューに渡されます。
// 4. イベントループで、コールスタックが空なことを確認し、タスクキューにある() => console.log(i)がコールスタックに渡されます。
// 5. () => console.log(i) が ループ内で定義されたiを返し、コールスタックからポップされ、プログラムは終了します。

//ループ内での値について;
// varで宣言したiの場合、ループ内では、はじめに定義したiを用いて、i+3されるまでコールスタックが空にならないので、setTimeoutはまってくれる。
// varはループ後の値として3を返却する。setTimeoutは3しか返却されていない状態で、3回繰りかえされていると解釈する。（実際は3を3回受け取っているのか？）
// よって 3,3,3

// letで宣言したiの場合、ブロックスコープごとにループ内のiが返却される。
//（ループ後のiではない。なぜならiはブロック外にはletで定義されていないためi=3は返却されない）
// よって 0,1,2

//letとクロージャについて
//let はループ内だけで有効なローカル変数。forループを抜けると変数が破棄されてアクセスできなくなります、
//それでは困るので、setTimeoutに渡す関数を定義する毎にその時点の外部変数を抱え込むようになっています。
//これをクロージャといいます。なので、ループごとの変数の値を表示できます。

//varをつかって012を表示させたい場合
// setTimeoutを抜けば良い
for (var i = 0; i < 3; i++) {
  console.log(i);
}
